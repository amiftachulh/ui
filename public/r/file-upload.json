{
  "name": "file-upload",
  "type": "registry:ui",
  "files": [
    {
      "path": "registry/default/ui/file-upload.tsx",
      "type": "registry:ui",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport {\n  LuFile,\n  LuFileArchive,\n  LuFileAudio,\n  LuFileCode,\n  LuFileCog,\n  LuFileText,\n  LuFileVideo,\n} from \"react-icons/lu\";\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { cx } from \"styled-system/css\";\nimport { styled } from \"styled-system/jsx\";\nimport { fileUpload } from \"styled-system/recipes\";\n\nconst classes = fileUpload();\n\nconst ROOT_NAME = \"FileUpload\";\nconst DROPZONE_NAME = \"FileUploadDropzone\";\nconst TRIGGER_NAME = \"FileUploadTrigger\";\nconst LIST_NAME = \"FileUploadList\";\nconst ITEM_NAME = \"FileUploadItem\";\nconst ITEM_PREVIEW_NAME = \"FileUploadItemPreview\";\nconst ITEM_METADATA_NAME = \"FileUploadItemMetadata\";\nconst ITEM_PROGRESS_NAME = \"FileUploadItemProgress\";\nconst ITEM_DELETE_NAME = \"FileUploadItemDelete\";\nconst CLEAR_NAME = \"FileUploadClear\";\n\nfunction useLazyRef<T>(fn: () => T) {\n  const ref = React.useRef<T | null>(null);\n\n  if (ref.current === null) {\n    ref.current = fn();\n  }\n\n  return ref as React.RefObject<T>;\n}\n\ntype Direction = \"ltr\" | \"rtl\";\n\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\n\nfunction useDirection(dirProp?: Direction): Direction {\n  const contextDir = React.useContext(DirectionContext);\n  return dirProp ?? contextDir ?? \"ltr\";\n}\n\ninterface FileState {\n  file: File;\n  progress: number;\n  error?: string;\n  status: \"idle\" | \"uploading\" | \"error\" | \"success\";\n}\n\ninterface StoreState {\n  files: Map<File, FileState>;\n  dragOver: boolean;\n  invalid: boolean;\n}\n\ntype StoreAction =\n  | { type: \"ADD_FILES\"; files: File[] }\n  | { type: \"SET_FILES\"; files: File[] }\n  | { type: \"SET_PROGRESS\"; file: File; progress: number }\n  | { type: \"SET_SUCCESS\"; file: File }\n  | { type: \"SET_ERROR\"; file: File; error: string }\n  | { type: \"REMOVE_FILE\"; file: File }\n  | { type: \"SET_DRAG_OVER\"; dragOver: boolean }\n  | { type: \"SET_INVALID\"; invalid: boolean }\n  | { type: \"CLEAR\" };\n\nfunction createStore(\n  listeners: Set<() => void>,\n  files: Map<File, FileState>,\n  urlCache: WeakMap<File, string>,\n  invalid: boolean,\n  onValueChange?: (files: File[]) => void\n) {\n  let state: StoreState = {\n    files,\n    dragOver: false,\n    invalid: invalid,\n  };\n\n  function reducer(state: StoreState, action: StoreAction): StoreState {\n    switch (action.type) {\n      case \"ADD_FILES\": {\n        for (const file of action.files) {\n          files.set(file, {\n            file,\n            progress: 0,\n            status: \"idle\",\n          });\n        }\n\n        if (onValueChange) {\n          const fileList = Array.from(files.values()).map((fileState) => fileState.file);\n          onValueChange(fileList);\n        }\n        return { ...state, files };\n      }\n\n      case \"SET_FILES\": {\n        const newFileSet = new Set(action.files);\n        for (const existingFile of files.keys()) {\n          if (!newFileSet.has(existingFile)) {\n            files.delete(existingFile);\n          }\n        }\n\n        for (const file of action.files) {\n          const existingState = files.get(file);\n          if (!existingState) {\n            files.set(file, {\n              file,\n              progress: 0,\n              status: \"idle\",\n            });\n          }\n        }\n        return { ...state, files };\n      }\n\n      case \"SET_PROGRESS\": {\n        const fileState = files.get(action.file);\n        if (fileState) {\n          files.set(action.file, {\n            ...fileState,\n            progress: action.progress,\n            status: \"uploading\",\n          });\n        }\n        return { ...state, files };\n      }\n\n      case \"SET_SUCCESS\": {\n        const fileState = files.get(action.file);\n        if (fileState) {\n          files.set(action.file, {\n            ...fileState,\n            progress: 100,\n            status: \"success\",\n          });\n        }\n        return { ...state, files };\n      }\n\n      case \"SET_ERROR\": {\n        const fileState = files.get(action.file);\n        if (fileState) {\n          files.set(action.file, {\n            ...fileState,\n            error: action.error,\n            status: \"error\",\n          });\n        }\n        return { ...state, files };\n      }\n\n      case \"REMOVE_FILE\": {\n        if (urlCache) {\n          const cachedUrl = urlCache.get(action.file);\n          if (cachedUrl) {\n            URL.revokeObjectURL(cachedUrl);\n            urlCache.delete(action.file);\n          }\n        }\n\n        files.delete(action.file);\n\n        if (onValueChange) {\n          const fileList = Array.from(files.values()).map((fileState) => fileState.file);\n          onValueChange(fileList);\n        }\n        return { ...state, files };\n      }\n\n      case \"SET_DRAG_OVER\": {\n        return { ...state, dragOver: action.dragOver };\n      }\n\n      case \"SET_INVALID\": {\n        return { ...state, invalid: action.invalid };\n      }\n\n      case \"CLEAR\": {\n        if (urlCache) {\n          for (const file of files.keys()) {\n            const cachedUrl = urlCache.get(file);\n            if (cachedUrl) {\n              URL.revokeObjectURL(cachedUrl);\n              urlCache.delete(file);\n            }\n          }\n        }\n\n        files.clear();\n        if (onValueChange) {\n          onValueChange([]);\n        }\n        return { ...state, files, invalid: false };\n      }\n\n      default:\n        return state;\n    }\n  }\n\n  function getState() {\n    return state;\n  }\n\n  function dispatch(action: StoreAction) {\n    state = reducer(state, action);\n    for (const listener of listeners) {\n      listener();\n    }\n  }\n\n  function subscribe(listener: () => void) {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  }\n\n  return { getState, dispatch, subscribe };\n}\n\nconst StoreContext = React.createContext<ReturnType<typeof createStore> | null>(null);\n\nfunction useStoreContext(consumerName: string) {\n  const context = React.useContext(StoreContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\nfunction useStore<T>(selector: (state: StoreState) => T): T {\n  const store = useStoreContext(\"useStore\");\n\n  const lastValueRef = useLazyRef<{ value: T; state: StoreState } | null>(() => null);\n\n  const getSnapshot = React.useCallback(() => {\n    const state = store.getState();\n    const prevValue = lastValueRef.current;\n\n    if (prevValue && prevValue.state === state) {\n      return prevValue.value;\n    }\n\n    const nextValue = selector(state);\n    lastValueRef.current = { value: nextValue, state };\n    return nextValue;\n  }, [store, selector, lastValueRef]);\n\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\n}\n\ninterface FileUploadContextValue {\n  inputId: string;\n  dropzoneId: string;\n  listId: string;\n  labelId: string;\n  disabled: boolean;\n  dir: Direction;\n  inputRef: React.RefObject<HTMLInputElement | null>;\n  urlCache: WeakMap<File, string>;\n}\n\nconst FileUploadContext = React.createContext<FileUploadContextValue | null>(null);\n\nfunction useFileUploadContext(consumerName: string) {\n  const context = React.useContext(FileUploadContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\ninterface FileUploadRootProps\n  extends Omit<React.ComponentProps<\"div\">, \"defaultValue\" | \"onChange\"> {\n  value?: File[];\n  defaultValue?: File[];\n  onValueChange?: (files: File[]) => void;\n  onAccept?: (files: File[]) => void;\n  onFileAccept?: (file: File) => void;\n  onFileReject?: (file: File, message: string) => void;\n  onFileValidate?: (file: File) => string | null | undefined;\n  onUpload?: (\n    files: File[],\n    options: {\n      onProgress: (file: File, progress: number) => void;\n      onSuccess: (file: File) => void;\n      onError: (file: File, error: Error) => void;\n    }\n  ) => Promise<void> | void;\n  accept?: string;\n  maxFiles?: number;\n  maxSize?: number;\n  dir?: Direction;\n  label?: string;\n  name?: string;\n  asChild?: boolean;\n  disabled?: boolean;\n  invalid?: boolean;\n  multiple?: boolean;\n  required?: boolean;\n}\n\nfunction Root(props: FileUploadRootProps) {\n  const {\n    value,\n    defaultValue,\n    onValueChange,\n    onAccept,\n    onFileAccept,\n    onFileReject,\n    onFileValidate,\n    onUpload,\n    accept,\n    maxFiles,\n    maxSize,\n    dir: dirProp,\n    label,\n    name,\n    asChild,\n    disabled = false,\n    invalid = false,\n    multiple = false,\n    required = false,\n    children,\n    className,\n    ...rootProps\n  } = props;\n\n  const inputId = React.useId();\n  const dropzoneId = React.useId();\n  const listId = React.useId();\n  const labelId = React.useId();\n\n  const dir = useDirection(dirProp);\n  const listeners = useLazyRef(() => new Set<() => void>()).current;\n  const files = useLazyRef<Map<File, FileState>>(() => new Map()).current;\n  const urlCache = useLazyRef(() => new WeakMap<File, string>()).current;\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const isControlled = value !== undefined;\n\n  const store = React.useMemo(\n    () => createStore(listeners, files, urlCache, invalid, onValueChange),\n    [listeners, files, invalid, onValueChange, urlCache]\n  );\n\n  const acceptTypes = React.useMemo(\n    () => accept?.split(\",\").map((t) => t.trim()) ?? null,\n    [accept]\n  );\n\n  const onProgress = useLazyRef(() => {\n    let frame = 0;\n    return (file: File, progress: number) => {\n      if (frame) return;\n      frame = requestAnimationFrame(() => {\n        frame = 0;\n        store.dispatch({\n          type: \"SET_PROGRESS\",\n          file,\n          progress: Math.min(Math.max(0, progress), 100),\n        });\n      });\n    };\n  }).current;\n\n  React.useEffect(() => {\n    if (isControlled) {\n      store.dispatch({ type: \"SET_FILES\", files: value });\n    } else if (defaultValue && defaultValue.length > 0 && !store.getState().files.size) {\n      store.dispatch({ type: \"SET_FILES\", files: defaultValue });\n    }\n  }, [value, defaultValue, isControlled, store]);\n\n  React.useEffect(() => {\n    return () => {\n      for (const file of files.keys()) {\n        const cachedUrl = urlCache.get(file);\n        if (cachedUrl) {\n          URL.revokeObjectURL(cachedUrl);\n        }\n      }\n    };\n  }, [files, urlCache]);\n\n  const onFilesUpload = React.useCallback(\n    async (files: File[]) => {\n      try {\n        for (const file of files) {\n          store.dispatch({ type: \"SET_PROGRESS\", file, progress: 0 });\n        }\n\n        if (onUpload) {\n          await onUpload(files, {\n            onProgress,\n            onSuccess: (file) => {\n              store.dispatch({ type: \"SET_SUCCESS\", file });\n            },\n            onError: (file, error) => {\n              store.dispatch({\n                type: \"SET_ERROR\",\n                file,\n                error: error.message ?? \"Upload failed\",\n              });\n            },\n          });\n        } else {\n          for (const file of files) {\n            store.dispatch({ type: \"SET_SUCCESS\", file });\n          }\n        }\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"Upload failed\";\n        for (const file of files) {\n          store.dispatch({\n            type: \"SET_ERROR\",\n            file,\n            error: errorMessage,\n          });\n        }\n      }\n    },\n    [store, onUpload, onProgress]\n  );\n\n  const onFilesChange = React.useCallback(\n    (originalFiles: File[]) => {\n      if (disabled) return;\n\n      let filesToProcess = [...originalFiles];\n      let invalid = false;\n\n      if (maxFiles) {\n        const currentCount = store.getState().files.size;\n        const remainingSlotCount = Math.max(0, maxFiles - currentCount);\n\n        if (remainingSlotCount < filesToProcess.length) {\n          const rejectedFiles = filesToProcess.slice(remainingSlotCount);\n          invalid = true;\n\n          filesToProcess = filesToProcess.slice(0, remainingSlotCount);\n\n          for (const file of rejectedFiles) {\n            let rejectionMessage = `Maximum ${maxFiles} files allowed`;\n\n            if (onFileValidate) {\n              const validationMessage = onFileValidate(file);\n              if (validationMessage) {\n                rejectionMessage = validationMessage;\n              }\n            }\n\n            onFileReject?.(file, rejectionMessage);\n          }\n        }\n      }\n\n      const acceptedFiles: File[] = [];\n      const rejectedFiles: { file: File; message: string }[] = [];\n\n      for (const file of filesToProcess) {\n        let rejected = false;\n        let rejectionMessage = \"\";\n\n        if (onFileValidate) {\n          const validationMessage = onFileValidate(file);\n          if (validationMessage) {\n            rejectionMessage = validationMessage;\n            onFileReject?.(file, rejectionMessage);\n            rejected = true;\n            invalid = true;\n            continue;\n          }\n        }\n\n        if (acceptTypes) {\n          const fileType = file.type;\n          const fileExtension = `.${file.name.split(\".\").pop()}`;\n\n          if (\n            !acceptTypes.some(\n              (type) =>\n                type === fileType ||\n                type === fileExtension ||\n                (type.includes(\"/*\") && fileType.startsWith(type.replace(\"/*\", \"/\")))\n            )\n          ) {\n            rejectionMessage = \"File type not accepted\";\n            onFileReject?.(file, rejectionMessage);\n            rejected = true;\n            invalid = true;\n          }\n        }\n\n        if (maxSize && file.size > maxSize) {\n          rejectionMessage = \"File too large\";\n          onFileReject?.(file, rejectionMessage);\n          rejected = true;\n          invalid = true;\n        }\n\n        if (!rejected) {\n          acceptedFiles.push(file);\n        } else {\n          rejectedFiles.push({ file, message: rejectionMessage });\n        }\n      }\n\n      if (invalid) {\n        store.dispatch({ type: \"SET_INVALID\", invalid });\n        setTimeout(() => {\n          store.dispatch({ type: \"SET_INVALID\", invalid: false });\n        }, 2000);\n      }\n\n      if (acceptedFiles.length > 0) {\n        store.dispatch({ type: \"ADD_FILES\", files: acceptedFiles });\n\n        if (isControlled && onValueChange) {\n          const currentFiles = Array.from(store.getState().files.values()).map((f) => f.file);\n          onValueChange([...currentFiles]);\n        }\n\n        if (onAccept) {\n          onAccept(acceptedFiles);\n        }\n\n        for (const file of acceptedFiles) {\n          onFileAccept?.(file);\n        }\n\n        if (onUpload) {\n          requestAnimationFrame(() => {\n            onFilesUpload(acceptedFiles);\n          });\n        }\n      }\n    },\n    [\n      store,\n      isControlled,\n      onValueChange,\n      onAccept,\n      onFileAccept,\n      onUpload,\n      onFilesUpload,\n      maxFiles,\n      onFileValidate,\n      onFileReject,\n      acceptTypes,\n      maxSize,\n      disabled,\n    ]\n  );\n\n  const onInputChange = React.useCallback(\n    (event: React.ChangeEvent<HTMLInputElement>) => {\n      const files = Array.from(event.target.files ?? []);\n      onFilesChange(files);\n      event.target.value = \"\";\n    },\n    [onFilesChange]\n  );\n\n  const contextValue = React.useMemo<FileUploadContextValue>(\n    () => ({\n      dropzoneId,\n      inputId,\n      listId,\n      labelId,\n      dir,\n      disabled,\n      inputRef,\n      urlCache,\n    }),\n    [dropzoneId, inputId, listId, labelId, dir, disabled, urlCache]\n  );\n\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <StoreContext.Provider value={store}>\n      <FileUploadContext.Provider value={contextValue}>\n        <Comp\n          data-disabled={disabled ? \"\" : undefined}\n          data-slot=\"file-upload\"\n          dir={dir}\n          className={cx(classes.root, className)}\n          {...rootProps}\n        >\n          {children}\n          <styled.input\n            type=\"file\"\n            id={inputId}\n            aria-labelledby={labelId}\n            aria-describedby={dropzoneId}\n            ref={inputRef}\n            tabIndex={-1}\n            accept={accept}\n            name={name}\n            css={{ srOnly: true }}\n            disabled={disabled}\n            multiple={multiple}\n            required={required}\n            onChange={onInputChange}\n          />\n          <styled.span id={labelId} css={{ srOnly: true }}>\n            {label ?? \"File upload\"}\n          </styled.span>\n        </Comp>\n      </FileUploadContext.Provider>\n    </StoreContext.Provider>\n  );\n}\nconst FileUpload = styled(Root);\n\ninterface FileUploadDropzoneProps extends React.ComponentProps<\"div\"> {\n  asChild?: boolean;\n}\n\nfunction Dropzone(props: FileUploadDropzoneProps) {\n  const {\n    asChild,\n    className,\n    onClick: onClickProp,\n    onDragOver: onDragOverProp,\n    onDragEnter: onDragEnterProp,\n    onDragLeave: onDragLeaveProp,\n    onDrop: onDropProp,\n    onPaste: onPasteProp,\n    onKeyDown: onKeyDownProp,\n    ...dropzoneProps\n  } = props;\n\n  const context = useFileUploadContext(DROPZONE_NAME);\n  const store = useStoreContext(DROPZONE_NAME);\n  const dragOver = useStore((state) => state.dragOver);\n  const invalid = useStore((state) => state.invalid);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLDivElement>) => {\n      onClickProp?.(event);\n\n      if (event.defaultPrevented) return;\n\n      const target = event.target;\n\n      const isFromTrigger =\n        target instanceof HTMLElement && target.closest('[data-slot=\"file-upload-trigger\"]');\n\n      if (!isFromTrigger) {\n        context.inputRef.current?.click();\n      }\n    },\n    [context.inputRef, onClickProp]\n  );\n\n  const onDragOver = React.useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragOverProp?.(event);\n\n      if (event.defaultPrevented) return;\n\n      event.preventDefault();\n      store.dispatch({ type: \"SET_DRAG_OVER\", dragOver: true });\n    },\n    [store, onDragOverProp]\n  );\n\n  const onDragEnter = React.useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragEnterProp?.(event);\n\n      if (event.defaultPrevented) return;\n\n      event.preventDefault();\n      store.dispatch({ type: \"SET_DRAG_OVER\", dragOver: true });\n    },\n    [store, onDragEnterProp]\n  );\n\n  const onDragLeave = React.useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragLeaveProp?.(event);\n\n      if (event.defaultPrevented) return;\n\n      const relatedTarget = event.relatedTarget;\n      if (\n        relatedTarget &&\n        relatedTarget instanceof Node &&\n        event.currentTarget.contains(relatedTarget)\n      ) {\n        return;\n      }\n\n      event.preventDefault();\n      store.dispatch({ type: \"SET_DRAG_OVER\", dragOver: false });\n    },\n    [store, onDragLeaveProp]\n  );\n\n  const onDrop = React.useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDropProp?.(event);\n\n      if (event.defaultPrevented) return;\n\n      event.preventDefault();\n      store.dispatch({ type: \"SET_DRAG_OVER\", dragOver: false });\n\n      const files = Array.from(event.dataTransfer.files);\n      const inputElement = context.inputRef.current;\n      if (!inputElement) return;\n\n      const dataTransfer = new DataTransfer();\n      for (const file of files) {\n        dataTransfer.items.add(file);\n      }\n\n      inputElement.files = dataTransfer.files;\n      inputElement.dispatchEvent(new Event(\"change\", { bubbles: true }));\n    },\n    [store, context.inputRef, onDropProp]\n  );\n\n  const onPaste = React.useCallback(\n    (event: React.ClipboardEvent<HTMLDivElement>) => {\n      onPasteProp?.(event);\n\n      if (event.defaultPrevented) return;\n\n      event.preventDefault();\n      store.dispatch({ type: \"SET_DRAG_OVER\", dragOver: false });\n\n      const items = event.clipboardData?.items;\n      if (!items) return;\n\n      const files: File[] = [];\n      for (let i = 0; i < items.length; i++) {\n        const item = items[i];\n        if (item?.kind === \"file\") {\n          const file = item.getAsFile();\n          if (file) {\n            files.push(file);\n          }\n        }\n      }\n\n      if (files.length === 0) return;\n\n      const inputElement = context.inputRef.current;\n      if (!inputElement) return;\n\n      const dataTransfer = new DataTransfer();\n      for (const file of files) {\n        dataTransfer.items.add(file);\n      }\n\n      inputElement.files = dataTransfer.files;\n      inputElement.dispatchEvent(new Event(\"change\", { bubbles: true }));\n    },\n    [store, context.inputRef, onPasteProp]\n  );\n\n  const onKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      onKeyDownProp?.(event);\n\n      if (!event.defaultPrevented && (event.key === \"Enter\" || event.key === \" \")) {\n        event.preventDefault();\n        context.inputRef.current?.click();\n      }\n    },\n    [context.inputRef, onKeyDownProp]\n  );\n\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <Comp\n      role=\"region\"\n      id={context.dropzoneId}\n      aria-controls={`${context.inputId} ${context.listId}`}\n      data-disabled={context.disabled ? \"\" : undefined}\n      data-dragging={dragOver ? \"\" : undefined}\n      data-invalid={invalid ? \"\" : undefined}\n      data-slot=\"file-upload-dropzone\"\n      dir={context.dir}\n      tabIndex={context.disabled ? undefined : 0}\n      {...dropzoneProps}\n      className={cx(classes.dropzone, className)}\n      onClick={onClick}\n      onDragEnter={onDragEnter}\n      onDragLeave={onDragLeave}\n      onDragOver={onDragOver}\n      onDrop={onDrop}\n      onKeyDown={onKeyDown}\n      onPaste={onPaste}\n    />\n  );\n}\nconst FileUploadDropzone = styled(Dropzone);\n\ninterface FileUploadTriggerProps extends React.ComponentProps<\"button\"> {\n  asChild?: boolean;\n}\n\nfunction Trigger(props: FileUploadTriggerProps) {\n  const { asChild, onClick: onClickProp, ...triggerProps } = props;\n  const context = useFileUploadContext(TRIGGER_NAME);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      onClickProp?.(event);\n\n      if (event.defaultPrevented) return;\n\n      context.inputRef.current?.click();\n    },\n    [context.inputRef, onClickProp]\n  );\n\n  const Comp = asChild ? Slot : \"button\";\n\n  return (\n    <Comp\n      type=\"button\"\n      aria-controls={context.inputId}\n      data-disabled={context.disabled ? \"\" : undefined}\n      data-slot=\"file-upload-trigger\"\n      disabled={context.disabled}\n      onClick={onClick}\n      {...triggerProps}\n    />\n  );\n}\nconst FileUploadTrigger = styled(Trigger);\n\ninterface FileUploadListProps extends React.ComponentProps<\"div\"> {\n  orientation?: \"horizontal\" | \"vertical\";\n  asChild?: boolean;\n  forceMount?: boolean;\n}\n\nfunction List(props: FileUploadListProps) {\n  const { className, orientation = \"vertical\", asChild, forceMount, ...listProps } = props;\n\n  const context = useFileUploadContext(LIST_NAME);\n  const fileCount = useStore((state) => state.files.size);\n  const shouldRender = forceMount || fileCount > 0;\n\n  if (!shouldRender) return null;\n\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <Comp\n      role=\"list\"\n      id={context.listId}\n      data-orientation={orientation}\n      data-slot=\"file-upload-list\"\n      data-state={shouldRender ? \"active\" : \"inactive\"}\n      dir={context.dir}\n      {...listProps}\n      className={cx(classes.list, className)}\n    />\n  );\n}\nconst FileUploadList = styled(List);\n\ninterface FileUploadItemContextValue {\n  id: string;\n  fileState: FileState | undefined;\n  nameId: string;\n  sizeId: string;\n  statusId: string;\n  messageId: string;\n}\n\nconst FileUploadItemContext = React.createContext<FileUploadItemContextValue | null>(null);\n\nfunction useFileUploadItemContext(consumerName: string) {\n  const context = React.useContext(FileUploadItemContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ITEM_NAME}\\``);\n  }\n  return context;\n}\n\ninterface FileUploadItemProps extends React.ComponentProps<\"div\"> {\n  value: File;\n  asChild?: boolean;\n}\n\nfunction Item(props: FileUploadItemProps) {\n  const { value, asChild, className, children, ...itemProps } = props;\n\n  const id = React.useId();\n  const statusId = `${id}-status`;\n  const nameId = `${id}-name`;\n  const sizeId = `${id}-size`;\n  const messageId = `${id}-message`;\n\n  const context = useFileUploadContext(ITEM_NAME);\n  const fileState = useStore((state) => state.files.get(value));\n  const fileCount = useStore((state) => state.files.size);\n  const fileIndex = useStore((state) => {\n    const files = Array.from(state.files.keys());\n    return files.indexOf(value) + 1;\n  });\n\n  const itemContext = React.useMemo(\n    () => ({\n      id,\n      fileState,\n      nameId,\n      sizeId,\n      statusId,\n      messageId,\n    }),\n    [id, fileState, statusId, nameId, sizeId, messageId]\n  );\n\n  if (!fileState) return null;\n\n  const statusText = fileState.error\n    ? `Error: ${fileState.error}`\n    : fileState.status === \"uploading\"\n      ? `Uploading: ${fileState.progress}% complete`\n      : fileState.status === \"success\"\n        ? \"Upload complete\"\n        : \"Ready to upload\";\n\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <FileUploadItemContext.Provider value={itemContext}>\n      <Comp\n        role=\"listitem\"\n        id={id}\n        aria-setsize={fileCount}\n        aria-posinset={fileIndex}\n        aria-describedby={`${nameId} ${sizeId} ${statusId} ${fileState.error ? messageId : \"\"}`}\n        aria-labelledby={nameId}\n        data-slot=\"file-upload-item\"\n        dir={context.dir}\n        {...itemProps}\n        className={cx(classes.item, className)}\n      >\n        {children}\n        <styled.span id={statusId} css={{ srOnly: true }}>\n          {statusText}\n        </styled.span>\n      </Comp>\n    </FileUploadItemContext.Provider>\n  );\n}\nconst FileUploadItem = styled(Item);\n\nfunction formatBytes(bytes: number) {\n  if (bytes === 0) return \"0 B\";\n  const sizes = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\"];\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\n  return `${(bytes / 1024 ** i).toFixed(i ? 1 : 0)} ${sizes[i]}`;\n}\n\nfunction getFileIcon(file: File) {\n  const type = file.type;\n  const extension = file.name.split(\".\").pop()?.toLowerCase() ?? \"\";\n\n  if (type.startsWith(\"video/\")) {\n    return <LuFileVideo />;\n  }\n\n  if (type.startsWith(\"audio/\")) {\n    return <LuFileAudio />;\n  }\n\n  if (type.startsWith(\"text/\") || [\"txt\", \"md\", \"rtf\", \"pdf\"].includes(extension)) {\n    return <LuFileText />;\n  }\n\n  if (\n    [\n      \"html\",\n      \"css\",\n      \"js\",\n      \"jsx\",\n      \"ts\",\n      \"tsx\",\n      \"json\",\n      \"xml\",\n      \"php\",\n      \"py\",\n      \"rb\",\n      \"java\",\n      \"c\",\n      \"cpp\",\n      \"cs\",\n    ].includes(extension)\n  ) {\n    return <LuFileCode />;\n  }\n\n  if ([\"zip\", \"rar\", \"7z\", \"tar\", \"gz\", \"bz2\"].includes(extension)) {\n    return <LuFileArchive />;\n  }\n\n  if (\n    [\"exe\", \"msi\", \"app\", \"apk\", \"deb\", \"rpm\"].includes(extension) ||\n    type.startsWith(\"application/\")\n  ) {\n    return <LuFileCog />;\n  }\n\n  return <LuFile />;\n}\n\ninterface FileUploadItemPreviewProps extends React.ComponentProps<\"div\"> {\n  render?: (file: File, fallback: () => React.ReactNode) => React.ReactNode;\n  asChild?: boolean;\n}\n\nfunction ItemPreview(props: FileUploadItemPreviewProps) {\n  const { render, asChild, children, className, ...previewProps } = props;\n\n  const itemContext = useFileUploadItemContext(ITEM_PREVIEW_NAME);\n  const context = useFileUploadContext(ITEM_PREVIEW_NAME);\n\n  const getDefaultRender = React.useCallback(\n    (file: File) => {\n      if (itemContext.fileState?.file.type.startsWith(\"image/\")) {\n        let url = context.urlCache.get(file);\n        if (!url) {\n          url = URL.createObjectURL(file);\n          context.urlCache.set(file, url);\n        }\n\n        return (\n          <styled.img\n            src={url}\n            alt={file.name}\n            css={{ w: \"full\", h: \"full\", objectFit: \"cover\" }}\n          />\n        );\n      }\n\n      return getFileIcon(file);\n    },\n    [itemContext.fileState?.file.type, context.urlCache]\n  );\n\n  const onPreviewRender = React.useCallback(\n    (file: File) => {\n      if (render) {\n        return render(file, () => getDefaultRender(file));\n      }\n\n      return getDefaultRender(file);\n    },\n    [render, getDefaultRender]\n  );\n\n  if (!itemContext.fileState) return null;\n\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <Comp\n      aria-labelledby={itemContext.nameId}\n      data-slot=\"file-upload-preview\"\n      className={cx(classes.itemPreview, className)}\n      {...previewProps}\n    >\n      {onPreviewRender(itemContext.fileState.file)}\n      {children}\n    </Comp>\n  );\n}\nconst FileUploadItemPreview = styled(ItemPreview);\n\ninterface FileUploadItemMetadataProps extends React.ComponentProps<\"div\"> {\n  asChild?: boolean;\n  size?: \"default\" | \"sm\";\n}\n\nfunction ItemMetadata(props: FileUploadItemMetadataProps) {\n  const { asChild, size = \"default\", children, className, ...metadataProps } = props;\n\n  const context = useFileUploadContext(ITEM_METADATA_NAME);\n  const itemContext = useFileUploadItemContext(ITEM_METADATA_NAME);\n\n  if (!itemContext.fileState) return null;\n\n  const ItemMetadataPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <ItemMetadataPrimitive\n      data-slot=\"file-upload-metadata\"\n      dir={context.dir}\n      className={cx(classes.itemMetadata, className)}\n      {...metadataProps}\n    >\n      {children ?? (\n        <>\n          <styled.span\n            id={itemContext.nameId}\n            data-size={size}\n            css={{\n              truncate: true,\n              fontWeight: \"medium\",\n              textStyle: \"sm\",\n              \"&[data-size=sm]\": {\n                fontWeight: \"normal\",\n                fontSize: \"0.8125rem\",\n                lineHeight: \"snug\",\n              },\n            }}\n          >\n            {itemContext.fileState.file.name}\n          </styled.span>\n          <styled.span\n            id={itemContext.sizeId}\n            data-size={size}\n            css={{\n              truncate: true,\n              color: \"muted.fg\",\n              textStyle: \"xs\",\n              \"&[data-size=sm]\": {\n                fontSize: \"0.6875rem\",\n                lineHeight: \"snug\",\n              },\n            }}\n          >\n            {formatBytes(itemContext.fileState.file.size)}\n          </styled.span>\n          {itemContext.fileState.error && (\n            <styled.span id={itemContext.messageId} css={{ color: \"danger\", textStyle: \"xs\" }}>\n              {itemContext.fileState.error}\n            </styled.span>\n          )}\n        </>\n      )}\n    </ItemMetadataPrimitive>\n  );\n}\nconst FileUploadItemMetadata = styled(ItemMetadata);\n\ninterface FileUploadItemProgressProps extends React.ComponentProps<\"div\"> {\n  variant?: \"linear\" | \"circular\" | \"fill\";\n  size?: number;\n  asChild?: boolean;\n  forceMount?: boolean;\n}\n\nfunction ItemProgress(props: FileUploadItemProgressProps) {\n  const { variant = \"linear\", size = 40, asChild, forceMount, className, ...progressProps } = props;\n\n  const itemContext = useFileUploadItemContext(ITEM_PROGRESS_NAME);\n\n  if (!itemContext.fileState) return null;\n\n  const shouldRender = forceMount || itemContext.fileState.progress !== 100;\n\n  if (!shouldRender) return null;\n\n  const Comp = asChild ? Slot : \"div\";\n\n  switch (variant) {\n    case \"circular\": {\n      const circumference = 2 * Math.PI * ((size - 4) / 2);\n      const strokeDashoffset =\n        circumference - (itemContext.fileState.progress / 100) * circumference;\n\n      return (\n        <Comp\n          role=\"progressbar\"\n          aria-valuemin={0}\n          aria-valuemax={100}\n          aria-valuenow={itemContext.fileState.progress}\n          aria-valuetext={`${itemContext.fileState.progress}%`}\n          aria-labelledby={itemContext.nameId}\n          data-slot=\"file-upload-progress\"\n          className={cx(classes.itemProgressCircular, className)}\n          {...progressProps}\n        >\n          <styled.svg\n            css={{ transform: \"rotate(-90deg)\" }}\n            width={size}\n            height={size}\n            viewBox={`0 0 ${size} ${size}`}\n            fill=\"none\"\n            stroke=\"currentColor\"\n          >\n            <styled.circle\n              css={{ color: \"primary/20\" }}\n              strokeWidth=\"2\"\n              cx={size / 2}\n              cy={size / 2}\n              r={(size - 4) / 2}\n            />\n            <styled.circle\n              css={{\n                color: \"primary\",\n                transitionProperty: \"stroke-dashoffset\",\n                transitionDuration: \"300ms\",\n                transitionTimingFunction: \"linear\",\n              }}\n              strokeWidth=\"2\"\n              strokeLinecap=\"round\"\n              strokeDasharray={circumference}\n              strokeDashoffset={strokeDashoffset}\n              cx={size / 2}\n              cy={size / 2}\n              r={(size - 4) / 2}\n            />\n          </styled.svg>\n        </Comp>\n      );\n    }\n\n    case \"fill\": {\n      const progressPercentage = itemContext.fileState.progress;\n      const topInset = 100 - progressPercentage;\n\n      return (\n        <Comp\n          role=\"progressbar\"\n          aria-valuemin={0}\n          aria-valuemax={100}\n          aria-valuenow={progressPercentage}\n          aria-valuetext={`${progressPercentage}%`}\n          aria-labelledby={itemContext.nameId}\n          data-slot=\"file-upload-progress\"\n          className={cx(classes.itemProgressFill, className)}\n          style={{\n            clipPath: `inset(${topInset}% 0% 0% 0%)`,\n          }}\n          {...progressProps}\n        />\n      );\n    }\n\n    default:\n      return (\n        <Comp\n          role=\"progressbar\"\n          aria-valuemin={0}\n          aria-valuemax={100}\n          aria-valuenow={itemContext.fileState.progress}\n          aria-valuetext={`${itemContext.fileState.progress}%`}\n          aria-labelledby={itemContext.nameId}\n          data-slot=\"file-upload-progress\"\n          className={cx(classes.itemProgress, className)}\n          {...progressProps}\n        >\n          <styled.div\n            css={{\n              w: \"full\",\n              h: \"full\",\n              flex: \"1\",\n              bg: \"primary\",\n              transitionProperty: \"transform\",\n              transitionDuration: \"300ms\",\n              transitionTimingFunction: \"linear\",\n            }}\n            style={{\n              transform: `translateX(-${100 - itemContext.fileState.progress}%)`,\n            }}\n          />\n        </Comp>\n      );\n  }\n}\nconst FileUploadItemProgress = styled(ItemProgress);\n\ninterface FileUploadItemDeleteProps extends React.ComponentProps<\"button\"> {\n  asChild?: boolean;\n}\n\nfunction ItemDelete(props: FileUploadItemDeleteProps) {\n  const { asChild, onClick: onClickProp, ...deleteProps } = props;\n\n  const store = useStoreContext(ITEM_DELETE_NAME);\n  const itemContext = useFileUploadItemContext(ITEM_DELETE_NAME);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      onClickProp?.(event);\n\n      if (!itemContext.fileState || event.defaultPrevented) return;\n\n      store.dispatch({\n        type: \"REMOVE_FILE\",\n        file: itemContext.fileState.file,\n      });\n    },\n    [store, itemContext.fileState, onClickProp]\n  );\n\n  if (!itemContext.fileState) return null;\n\n  const ItemDeletePrimitive = asChild ? Slot : \"button\";\n\n  return (\n    <ItemDeletePrimitive\n      type=\"button\"\n      aria-controls={itemContext.id}\n      aria-describedby={itemContext.nameId}\n      data-slot=\"file-upload-item-delete\"\n      onClick={onClick}\n      {...deleteProps}\n    />\n  );\n}\nconst FileUploadItemDelete = styled(ItemDelete);\n\ninterface FileUploadClearProps extends React.ComponentProps<\"button\"> {\n  forceMount?: boolean;\n  asChild?: boolean;\n}\n\nfunction Clear(props: FileUploadClearProps) {\n  const { asChild, forceMount, disabled, onClick: onClickProp, ...clearProps } = props;\n\n  const context = useFileUploadContext(CLEAR_NAME);\n  const store = useStoreContext(CLEAR_NAME);\n  const fileCount = useStore((state) => state.files.size);\n\n  const isDisabled = disabled || context.disabled;\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      onClickProp?.(event);\n\n      if (event.defaultPrevented) return;\n\n      store.dispatch({ type: \"CLEAR\" });\n    },\n    [store, onClickProp]\n  );\n\n  const shouldRender = forceMount || fileCount > 0;\n\n  if (!shouldRender) return null;\n\n  const Comp = asChild ? Slot : \"button\";\n\n  return (\n    <Comp\n      type=\"button\"\n      aria-controls={context.listId}\n      data-slot=\"file-upload-clear\"\n      data-disabled={isDisabled ? \"\" : undefined}\n      disabled={isDisabled}\n      onClick={onClick}\n      {...clearProps}\n    />\n  );\n}\nconst FileUploadClear = styled(Clear);\n\nexport {\n  FileUpload,\n  FileUploadDropzone,\n  FileUploadTrigger,\n  FileUploadList,\n  FileUploadItem,\n  FileUploadItemPreview,\n  FileUploadItemMetadata,\n  FileUploadItemProgress,\n  FileUploadItemDelete,\n  FileUploadClear,\n  //\n  useStore as useFileUpload,\n  //\n  type FileUploadRootProps as FileUploadProps,\n};\n"
    },
    {
      "path": "registry/default/slot-recipes/file-upload.ts",
      "type": "registry:slot-recipe",
      "content": "import { defineSlotRecipe } from \"@pandacss/dev\";\n\nexport const fileUploadSlotRecipe = defineSlotRecipe({\n  className: \"file-upload\",\n  slots: [\n    \"root\",\n    \"dropzone\",\n    \"trigger\",\n    \"list\",\n    \"item\",\n    \"itemPreview\",\n    \"itemMetadata\",\n    \"itemProgress\",\n    \"itemProgressCircular\",\n    \"itemProgressFill\",\n    \"itemDelete\",\n    \"clear\",\n  ],\n  base: {\n    root: {\n      pos: \"relative\",\n      display: \"flex\",\n      flexDir: \"column\",\n      gap: \"2\",\n    },\n\n    dropzone: {\n      pos: \"relative\",\n      display: \"flex\",\n      flexDir: \"column\",\n      alignItems: \"center\",\n      justifyContent: \"center\",\n      gap: \"2\",\n      p: \"6\",\n      borderWidth: \"2px\",\n      borderStyle: \"dashed\",\n      rounded: \"lg\",\n      outline: \"none\",\n      transitionProperty: \"background-color, border-color, outline-color\",\n      transitionDuration: \"200ms\",\n      transitionTimingFunction: \"ease-in-out\",\n      userSelect: \"none\",\n      _hover: {\n        bg: \"accent/30\",\n      },\n      _focusVisible: {\n        borderColor: \"ring/50\",\n      },\n      \"&[data-disabled]\": {\n        pointerEvents: \"none\",\n      },\n      \"&[data-dragging]\": {\n        bg: \"accent/30\",\n        borderColor: \"primary/30\",\n      },\n      \"&[data-invalid]\": {\n        borderColor: \"danger\",\n        outlineColor: \"danger/20\",\n      },\n    },\n\n    trigger: {},\n\n    list: {\n      display: \"flex\",\n      flexDir: \"column\",\n      gap: \"2\",\n      \"&[data-state=active]\": {\n        animateIn: true,\n        fadeIn: \"0\",\n        slideInFromTop: \"2\",\n      },\n      \"&[data-state=inactive]\": {\n        animateOut: true,\n        fadeOut: \"0\",\n        slideOutToTop: \"2\",\n      },\n      \"&[data-orientation=horizontal]\": {\n        flexDir: \"row\",\n        overflowX: \"auto\",\n        p: \"1.5\",\n      },\n    },\n\n    item: {\n      pos: \"relative\",\n      display: \"flex\",\n      alignItems: \"center\",\n      gap: \"2.5\",\n      rounded: \"md\",\n      borderWidth: \"1px\",\n      p: \"3\",\n    },\n\n    itemPreview: {\n      pos: \"relative\",\n      display: \"flex\",\n      w: \"10\",\n      h: \"10\",\n      flexShrink: \"0\",\n      alignItems: \"center\",\n      justifyContent: \"center\",\n      overflow: \"hidden\",\n      rounded: \"md\",\n      borderWidth: \"1px\",\n      bg: \"accent/50\",\n      \"& > svg\": {\n        w: \"10\",\n        h: \"10\",\n      },\n    },\n\n    itemMetadata: {\n      display: \"flex\",\n      minW: \"0\",\n      flex: \"1\",\n      flexDir: \"column\",\n    },\n\n    itemProgress: {\n      pos: \"relative\",\n      w: \"full\",\n      h: \"1.5\",\n      overflow: \"hidden\",\n      rounded: \"full\",\n      bg: \"primary/20\",\n    },\n\n    itemProgressCircular: {\n      pos: \"absolute\",\n      top: \"50%\",\n      left: \"50%\",\n      transform: \"translate(-50%, -50%)\",\n    },\n\n    itemProgressFill: {\n      pos: \"absolute\",\n      inset: \"0\",\n      bg: \"primary/50\",\n      transitionProperty: \"clip-path\",\n      transitionDuration: \"300ms\",\n      transitionTimingFunction: \"linear\",\n    },\n\n    itemDelete: {},\n\n    clear: {},\n  },\n});\n"
    }
  ]
}